\documentclass[aspectratio=169]{beamer}

\usepackage{amsmath,amssymb,bussproofs,proof,stmaryrd}

\title{Introduction to Proving Stuff\textsuperscript{\texttrademark} with Logical Relations}
\author{Jesse Sigal}
\date{November 7, 2024}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Attribution}
Slides with $*$ at the end of their title were written with the help of GPT 4o.
\end{frame}

\begin{frame}
\frametitle{Types*}
\[
\alpha, \beta ::= \tau \mid 1 \mid \alpha_1 \times \alpha_2 \mid \alpha \rightarrow \beta
\]

Where:
\begin{itemize}
    \item $\tau$ is a ground type from a fixed set of symbols, e.g.\ $\{\text{Int}, \text{Bool}, \ldots\},$
    \item $1$ is the unit type,
    \item $\alpha_1 \times \alpha_2$ is a product type,
    \item $\alpha \rightarrow \beta$ is a function type.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Signature}
A signature $\Sigma = (\Sigma_{\text{const}}, \Sigma_{\text{func}})$ is composed of two sets, namely
\begin{itemize}
    \item $\Sigma_{\text{const}}$ whose elements are constant symbols $c : \tau$; and
    \item $\Sigma_{\text{func}}$ whose elements are function symbols $f : (\tau_1, \ldots, \tau_n) \to \sigma$.
\end{itemize}
Everything is defined with respect to a signature $\Sigma$.

\end{frame}

\begin{frame}
\frametitle{Syntax*}

\[
M, N ::= x \mid c \mid f(M_1, \ldots, M_n) \mid \lambda x: \alpha. M \mid M \, N \mid \langle M_1, M_2 \rangle \mid \pi_1(M) \mid \pi_2(M)
\]

Where:
\begin{itemize}
    \item $x$ is a variable from a countably infinite set $\{x, y, z, \ldots \}$,
    \item $\langle \rangle$ is the term of type $1$,
    \item $c$ is a constant symbol in $\Sigma_{\text{const}}$,
    \item $f$ is a function symbol in $\Sigma_{\text{func}}$,
    \item $\lambda x: \alpha. M$ is lambda abstraction with $\alpha$ is a type,
    \item $M\, N$ is application,
    \item $\langle M_1, M_2 \rangle$ is a product,
    \item $\pi_1(M)$ and $\pi_2(M)$ are projections.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Free variables*}
The function $\text{FV}(M)$ is defined recursively as follows:
\begin{itemize}
    \item $\text{FV}(x) = \{x\}$
    \item $\text{FV}(\langle \rangle) = \emptyset$
    \item $\text{FV}(c) = \emptyset$
    \item $\text{FV}(f(M_1, \ldots, M_n)) = \bigcup_{i=1}^{n} \text{FV}(M_i)$
    \item $\text{FV}(\lambda x: \alpha. M) = \text{FV}(M) \setminus \{x\}$
    \item $\text{FV}(M \, N) = \text{FV}(M) \cup \text{FV}(N)$
    \item $\text{FV}(\langle M_1, M_2 \rangle) = \text{FV}(M_1) \cup \text{FV}(M_2)$
    \item $\text{FV}(\pi_1(M)) = \text{FV}(M)$
    \item $\text{FV}(\pi_2(M)) = \text{FV}(M)$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Capture-avoiding substitution*}

Substitution of $N$ for $x$ in $M$ in a capture-avoiding way, denoted $M[x := N]$, is defined recursively as follows:

\begin{itemize}
    \item $x[x := N] = N$
    \item $y[x := N] = y$, for $y \neq x$
    \item $\langle \rangle[x := N] = \langle \rangle$
    \item $c[x := N] = c$
    \item $f(M_1, \ldots, M_n)[x := N] = f(M_1[x := N], \ldots, M_n[x := N]))$
    \item $(M \, P)[x := N] = (M[x := N]) \, (P[x := N])$
    \item $\langle M_1 , M_2 \rangle[x := N] = \langle M_1[x := N], M_2[x := N] \rangle$
    \item $\pi_1(M)[x := N] = \pi_1(M[x := N])$
    \item $\pi_2(M)[x := N] = \pi_2(M[x := N])$
    \item $(\lambda y : \alpha. M)[x := N] =
    \begin{cases}
    \lambda y : \alpha. M[x := N] & \text{if } y \neq x \text{ and } y \notin \text{FV}(N) \\
    \lambda z : \alpha. M[y := z][x := N] & \text{if } y = x \text{ or } y \in \text{FV}(N)
    \end{cases}$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Typing Judgments*}

\[
\infer{\Gamma \vdash x : \alpha}{(x : \alpha) \in \Gamma}
\qquad
\infer{\Gamma \vdash \langle \rangle : 1}{}
\qquad
\infer{\Gamma \vdash c : \tau}{c : \tau \in \Sigma_{\text{const}}}
\]

\[
\infer{\Gamma \vdash f(M_1, \ldots, M_n) : \sigma}{\Gamma \vdash M_1 : \tau_1 & \ldots & \Gamma \vdash M_n : \tau_n & f : (\tau_1, \ldots, \tau_n) \rightarrow \sigma \in \Sigma_{\text{func}}}
\]

\[
\infer{\Gamma \vdash \lambda x : \alpha. M : \alpha \rightarrow \beta}{\Gamma, x : \alpha \vdash M : \beta}
\qquad
\infer{\Gamma \vdash M \, N : \beta}{\Gamma \vdash M : \alpha \rightarrow \beta & \Gamma \vdash N : \alpha}
\]

\[
\infer{\Gamma \vdash \langle M_1, M_2 \rangle : \alpha_1 \times \alpha_2}{\Gamma \vdash M_1 : \alpha & \Gamma \vdash M_2 : \alpha_2}
\qquad
\infer{\Gamma \vdash \pi_1(M) : \alpha_1}{\Gamma \vdash M : \alpha_1 \times \alpha_2}
\qquad
\infer{\Gamma \vdash \pi_2(M) : \alpha_2}{\Gamma \vdash M : \alpha_1 \times \alpha_2}
\]
\end{frame}

\begin{frame}
\frametitle{Denotational Semantics*}

\textbf{Interpretation of Types}:

\begin{itemize}
    \item $\llbracket \tau \rrbracket = G_\tau$
    \item $\llbracket 1 \rrbracket = \{\star\}$
    \item $\llbracket \alpha_1 \times \alpha_2 \rrbracket = \llbracket \alpha_1 \rrbracket \times \llbracket \alpha_2 \rrbracket$
    \item $\llbracket \alpha \rightarrow \beta \rrbracket = \llbracket \alpha \rrbracket \rightarrow \llbracket \beta \rrbracket$
\end{itemize}

\textbf{Interpretation of Terms} (given environment $\rho$):
\begin{itemize}
    \item $\llbracket x \rrbracket_\rho = \rho(x)$
    \item $\llbracket \langle \rangle \rrbracket_\rho = \star$
    \item $\llbracket c \rrbracket_\rho = c$
    \item $\llbracket f(M_1, \ldots, M_n) \rrbracket_\rho = f(\llbracket M_1 \rrbracket_\rho, \ldots, \llbracket M_n \rrbracket_\rho)$
    \item $\llbracket \lambda x : \alpha. M \rrbracket_\rho = \lambda a \in \llbracket \alpha \rrbracket. \llbracket M \rrbracket_{\rho[x := a]}$
    \item $\llbracket M \, N \rrbracket_\rho = \llbracket M \rrbracket_\rho (\llbracket N \rrbracket_\rho)$
    \item $\llbracket \langle M_1, M_2 \rangle \rrbracket_\rho = (\llbracket M_1 \rrbracket_\rho, \llbracket M_2 \rrbracket_\rho)$
    \item $\llbracket \pi_1(M) \rrbracket_\rho = \pi_1(\llbracket M \rrbracket_\rho)$
    \item $\llbracket \pi_2(M) \rrbracket_\rho = \pi_2(\llbracket M \rrbracket_\rho)$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Equations-in-Context*}

An equation-in-context is expressed as:
\[
\Gamma \vdash M = N : \alpha
\]

The judgments means that in the type context $\Gamma$, the terms $M$ and $N$ are considered equal and both have type $\alpha$.

\medskip

Equations-in-contexts allow us to perform equational reasoning while respecting the types assigned to the variables involved.
\end{frame}

\begin{frame}
\frametitle{Equational Reasoning Rules*}

\[
\infer[\text{(Refl)}]{\Gamma \vdash M = M : \alpha}{\Gamma \vdash M : \alpha}
\]

\[
\infer[\text{(Sym)}]{\Gamma \vdash N = M : \alpha}{\Gamma \vdash M = N : \alpha}
\]

\[
\infer[\text{(Trans)}]{\Gamma \vdash M = P : \alpha}{\Gamma \vdash M = N : \alpha & \Gamma \vdash N = P : \alpha}
\]
\end{frame}

\begin{frame}
\frametitle{Weakening and Substitution Rules*}

\[
\infer[\text{(Weak)}]{\Gamma, x : \beta \vdash M = N : \alpha}{\Gamma \vdash M = N : \alpha}
\]

\[
\infer[\text{(Subs)}]{\Gamma \vdash M[x := P] = N[x := P] : \alpha}{\Gamma, x : \beta \vdash M = N : \alpha & \Gamma \vdash P : \beta}
\]
\end{frame}

\begin{frame}
\frametitle{Rules for Unit and Binary Products*}

\[
\infer[\text{(Unit-Eq)}]{\Gamma \vdash M = \langle\rangle : 1}{\Gamma \vdash M : 1}
\]

\[
\infer[\text{(Proj1)}]{\Gamma \vdash \pi_1(\langle M_1, M_2 \rangle) = M_1 : \alpha_1}{\Gamma \vdash M_1 : \alpha_1 & \Gamma \vdash M_2 : \alpha_2}
\]

\[
\infer[\text{(Proj2)}]{\Gamma \vdash \pi_2(\langle M_1, M_2 \rangle) = M_2 : \alpha_2}{\Gamma \vdash M_1 : \alpha_1 & \Gamma \vdash M_2 : \alpha_2}
\]

\[
\infer[\text{($\eta$-Prod)}]{\Gamma \vdash \langle \pi_1(P), \pi_2(P) \rangle = P : \alpha_1 \times \alpha_2}{\Gamma \vdash P : \alpha_1 \times \alpha_2}
\]
\end{frame}

\begin{frame}
\frametitle{Rules for Functions*}

\[
\infer[\text{($\beta$-Eq)}]{\Gamma \vdash (\lambda x : \alpha. M) \, N = M[x := N] : \beta}{\Gamma \vdash N : \alpha}
\]

\[
\infer[\text{($\eta$-Eq)}]{\Gamma \vdash \lambda x : \alpha. (M \, x) = M : \alpha \rightarrow \beta}{x \not\in \text{FV}(M)}
\]

\[
\infer[\text{($\lambda$-Cong)}]{\Gamma \vdash \lambda x : \alpha. M = \lambda x : \alpha. N : \alpha \rightarrow \beta}{\Gamma, x : \alpha \vdash M = N : \beta}
\]

\end{frame}

\end{document}
