\documentclass[aspectratio=169]{beamer}

\usepackage[style=authoryear]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{stmaryrd}

\title{Introduction to Proving Stuff\textsuperscript{\texttrademark} with Logical Relations}
\author{Jesse Sigal}
\date{November 7, 2024}

\addbibresource{refs.bib}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Attribution}
\begin{itemize}
\item Slides with $*$ at the end of their title were written with the help of GPT 4o.
\item Most things for the calculus are in line with \cite{Crole_1994}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Overview}
\begin{itemize}
    \item What do we want to prove?
    \item Lambda calculus (review?)
    \begin{itemize}
        \item Types
        \item Signature
        \item Syntax
        \item Free variables
        \item Substitution
        \item Typing judgments
        \item Equations-in-context
        \item Equational reasoning rules
        \item Denotational semantics
        \item Soundness
    \end{itemize}
    \item Logical relations
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{What do we want to prove?}

\begin{itemize}
    \item When we write programs, we want to be able to reason about what they do.
    \pause
    \item But what if we want to prove something about \emph{all} programs in a language?
    \pause
    \item For example, if we have a language with an integer type, addition, and multiplication.
    \pause
    \item How could we prove that if we only ever input even numbers that we always get even numbers out?
    \pause
    \item Logical relations is a proof method that lets us easily prove the above, as well as many more complicated and interesting theorems.
    \pause
    \item For example, we can prove that every simply typed lambda calculus term terminates!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Types*}
\[
\alpha, \beta ::= \tau \mid 1 \mid \alpha_1 \times \alpha_2 \mid \alpha \rightarrow \beta
\]

Where:
\begin{itemize}
    \item $\tau$ is a ground type from a fixed set of symbols, e.g.\ $\{\text{Int}, \text{Bool}, \ldots\},$
    \item $1$ is the unit type,
    \item $\alpha_1 \times \alpha_2$ is a product type,
    \item $\alpha \rightarrow \beta$ is a function type.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Signature}
A signature $\Sigma = (\Sigma_{\text{const}}, \Sigma_{\text{func}})$ is composed of two sets, namely
\begin{itemize}
    \item $\Sigma_{\text{const}}$ whose elements are constant symbols $c : \tau$; and
    \item $\Sigma_{\text{func}}$ whose elements are function symbols $f : (\tau_1, \ldots, \tau_n) \to \tau$.
\end{itemize}
Everything is defined with respect to a signature $\Sigma$.

\medskip

For example, assume that we have $\text{Int}$ as ground type.
Then we could defined $\Sigma = \left(\{\underline{i} : i \in \mathbb{Z}\}, \{+, \times\}\right)$ 

\end{frame}

\begin{frame}
\frametitle{Syntax*}

\[
M, N ::= x \mid \langle \rangle \mid c \mid f(M_1, \ldots, M_n) \mid \lambda x: \alpha. M \mid M \, N \mid \langle M_1, M_2 \rangle \mid \pi_1(M) \mid \pi_2(M)
\]

Where:
\begin{itemize}
    \item $x$ is a variable from a countably infinite set $\{x, y, z, \ldots \}$,
    \item $\langle \rangle$ is the term of type $1$,
    \item $c$ is a constant symbol in $\Sigma_{\text{const}}$,
    \item $f$ is a function symbol in $\Sigma_{\text{func}}$,
    \item $\lambda x: \alpha. M$ is lambda abstraction with $\alpha$ is a type,
    \item $M\, N$ is application,
    \item $\langle M_1, M_2 \rangle$ is a product,
    \item $\pi_1(M)$ and $\pi_2(M)$ are projections.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Free variables*}
The function $\text{FV}(M)$ is defined recursively as follows:
\begin{itemize}
    \item $\text{FV}(x) = \{x\}$
    \item $\text{FV}(\langle \rangle) = \emptyset$
    \item $\text{FV}(c) = \emptyset$
    \item $\text{FV}(f(M_1, \ldots, M_n)) = \bigcup_{i=1}^{n} \text{FV}(M_i)$
    \pause
    \item $\text{FV}(\lambda x: \alpha. M) = \text{FV}(M) \setminus \{x\}$
    \pause
    \item $\text{FV}(M \, N) = \text{FV}(M) \cup \text{FV}(N)$
    \item $\text{FV}(\langle M_1, M_2 \rangle) = \text{FV}(M_1) \cup \text{FV}(M_2)$
    \item $\text{FV}(\pi_1(M)) = \text{FV}(M)$
    \item $\text{FV}(\pi_2(M)) = \text{FV}(M)$
\end{itemize}

\pause
For example, $\text{FV}(\lambda x: \alpha. y \, x) = \{y\}$.

\end{frame}

\begin{frame}
\frametitle{Capture-avoiding substitution*}

Substitution of $N$ for $x$ in $M$ in a capture-avoiding way, denoted $M[x := N]$, is defined recursively as follows:

\begin{itemize}
    \item $x[x := N] = N$
    \item $y[x := N] = y$, for $y \neq x$
    \pause
    \item $\langle \rangle[x := N] = \langle \rangle$
    \item $c[x := N] = c$
    \pause
    \item $f(M_1, \ldots, M_n)[x := N] = f(M_1[x := N], \ldots, M_n[x := N]))$
    \item $(M \, P)[x := N] = (M[x := N]) \, (P[x := N])$
    \item $\langle M_1 , M_2 \rangle[x := N] = \langle M_1[x := N], M_2[x := N] \rangle$
    \item $\pi_1(M)[x := N] = \pi_1(M[x := N])$
    \item $\pi_2(M)[x := N] = \pi_2(M[x := N])$
    \item $\ldots$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Capture-avoiding substitution (continued)*}

Most importantly, we have the rule for abstraction:

\begin{itemize}
    \item $(\lambda y : \alpha. M)[x := N] =
    \begin{cases}
    \lambda y : \alpha. M[x := N] & \text{if } y \neq x \text{ and } y \notin \text{FV}(N) \\
    \lambda z : \alpha. M[y := z][x := N] & \text{if } y = x \text{ or } y \in \text{FV}(N)
    \end{cases}$
\end{itemize}
\pause
Here are two examples:
\begin{itemize}
    \item $(\lambda y : \alpha. x)[x := z] = \lambda y : \alpha. z$
    \item $(\lambda y : \alpha. y \, x)[x := y] = \lambda z : \alpha. z \, y$
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Typing Judgments*}

\[
\infer{\Gamma \vdash x : \alpha}{(x : \alpha) \in \Gamma}
\qquad
\infer{\Gamma \vdash \langle \rangle : 1}{}
\qquad
\infer{\Gamma \vdash c : \tau}{c : \tau \in \Sigma_{\text{const}}}
\]
\pause
\[
\infer{\Gamma \vdash f(M_1, \ldots, M_n) : \tau}{\Gamma \vdash M_1 : \tau_1 & \ldots & \Gamma \vdash M_n : \tau_n & f : (\tau_1, \ldots, \tau_n) \rightarrow \tau \in \Sigma_{\text{func}}}
\]
\pause
\[
\infer{\Gamma \vdash \lambda x : \alpha. M : \alpha \rightarrow \beta}{\Gamma, x : \alpha \vdash M : \beta}
\qquad
\infer{\Gamma \vdash M \, N : \beta}{\Gamma \vdash M : \alpha \rightarrow \beta & \Gamma \vdash N : \alpha}
\]
\pause
\[
\infer{\Gamma \vdash \langle M_1, M_2 \rangle : \alpha_1 \times \alpha_2}{\Gamma \vdash M_1 : \alpha & \Gamma \vdash M_2 : \alpha_2}
\qquad
\infer{\Gamma \vdash \pi_1(M) : \alpha_1}{\Gamma \vdash M : \alpha_1 \times \alpha_2}
\qquad
\infer{\Gamma \vdash \pi_2(M) : \alpha_2}{\Gamma \vdash M : \alpha_1 \times \alpha_2}
\]
\end{frame}

\begin{frame}
\frametitle{Equations-in-Context*}

An equation-in-context is expressed as:
\[
\Gamma \vdash M = N : \alpha
\]

The judgments means that in the type context $\Gamma$, the terms $M$ and $N$ are considered equal and both have type $\alpha$.

\medskip

Equations-in-contexts allow us to perform equational reasoning while respecting the types assigned to the variables involved.

\end{frame}

\begin{frame}
\frametitle{Equational Reasoning Rules*}

\[
\infer[\text{(Refl)}]{\Gamma \vdash M = M : \alpha}{\Gamma \vdash M : \alpha}
\]

\[
\infer[\text{(Sym)}]{\Gamma \vdash N = M : \alpha}{\Gamma \vdash M = N : \alpha}
\]

\[
\infer[\text{(Trans)}]{\Gamma \vdash M = P : \alpha}{\Gamma \vdash M = N : \alpha & \Gamma \vdash N = P : \alpha}
\]
\end{frame}

\begin{frame}
\frametitle{Weakening and Substitution Rules*}

\[
\infer[\text{(Weak)}]{\Gamma, x : \beta \vdash M = N : \alpha}{\Gamma \vdash M = N : \alpha}
\]

\[
\infer[\text{(Subs)}]{\Gamma \vdash M[x := P] = N[x := P] : \alpha}{\Gamma, x : \beta \vdash M = N : \alpha & \Gamma \vdash P : \beta}
\]
\end{frame}

\begin{frame}
\frametitle{Rules for Unit and Binary Products*}

\[
\infer[\text{(Unit-Eq)}]{\Gamma \vdash M = \langle\rangle : 1}{\Gamma \vdash M : 1}
\]

\[
\infer[\text{(Proj1)}]{\Gamma \vdash \pi_1(\langle M_1, M_2 \rangle) = M_1 : \alpha_1}{\Gamma \vdash M_1 : \alpha_1 & \Gamma \vdash M_2 : \alpha_2}
\]

\[
\infer[\text{(Proj2)}]{\Gamma \vdash \pi_2(\langle M_1, M_2 \rangle) = M_2 : \alpha_2}{\Gamma \vdash M_1 : \alpha_1 & \Gamma \vdash M_2 : \alpha_2}
\]

\[
\infer[\text{($\eta$-Prod)}]{\Gamma \vdash \langle \pi_1(P), \pi_2(P) \rangle = P : \alpha_1 \times \alpha_2}{\Gamma \vdash P : \alpha_1 \times \alpha_2}
\]
\end{frame}

\begin{frame}
\frametitle{Rules for Functions*}

\[
\infer[\text{($\beta$-Eq)}]{\Gamma \vdash (\lambda x : \alpha. M) \, N = M[x := N] : \beta}{\Gamma \vdash N : \alpha}
\]

\[
\infer[\text{($\eta$-Eq)}]{\Gamma \vdash \lambda x : \alpha. (M \, x) = M : \alpha \rightarrow \beta}{x \not\in \text{FV}(M)}
\]

\[
\infer[\text{($\lambda$-Cong)}]{\Gamma \vdash \lambda x : \alpha. M = \lambda x : \alpha. N : \alpha \rightarrow \beta}{\Gamma, x : \alpha \vdash M = N : \beta}
\]

\end{frame}

\begin{frame}
\frametitle{Axioms}
We also want axioms in order to reason about elements of our signature $\Sigma$.
An axiom is a pair of terms $\left(\Gamma \vdash M : \alpha, \Gamma \vdash N : \alpha\right)$ of terms of the same type in the same context.
For a set of axioms $\Omega$, we have the rule
\[
\infer[\text{(Axiom)}]{\Gamma \vdash M = N : \alpha}{\left(\Gamma \vdash M : \alpha, \Gamma \vdash N : \alpha\right) \in \Omega}
\]
Note that it is possible to prove false if you choose your axioms wrong!
\end{frame}

\begin{frame}
\frametitle{Set-Theoretic Denotational Semantics for Types*}

Let $\rho$ be a function that assigns a set $\rho(\tau)$ to each ground type $\tau$, e.g., $\rho(\text{Int}) = \mathbb{Z}$, $\rho(\text{Bool}) = \{ \text{true}, \text{false} \}$.

\pause
\medskip

Then to type $\alpha$, we are going to assign a set $\llbracket \alpha \rrbracket_{\rho}$ as follows:

\begin{itemize}
    \item $\llbracket \tau \rrbracket_{\rho} = \rho(\tau)$
    \item $\llbracket 1 \rrbracket_{\rho} = \{\star\}$
    \item $\llbracket \alpha_1 \times \alpha_2 \rrbracket_{\rho} = \llbracket \alpha_1 \rrbracket_{\rho} \times \llbracket \alpha_2 \rrbracket_{\rho}$
    \item $\llbracket \alpha \rightarrow \beta \rrbracket_{\rho} = \llbracket \alpha \rrbracket_{\rho} \rightarrow \llbracket \beta \rrbracket_{\rho}$
\end{itemize}

Where:
\begin{itemize}
    \item $\{\star\}$ is a singleton set of exactly one element;
    \item $\times$ denotes the Cartesian product of sets; and
    \item $\rightarrow$ denotes the set of functions.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Set-Theoretic Denotational Semantics for Signatures}

For a fixed $\rho$ assigning ground types to sets, we can give an interpretation $\sigma$  to the constants and functions of a signature $\Sigma = (\Sigma_{\text{const}}, \Sigma_{\text{func}})$:
\begin{itemize}
    \item for each $c : \tau \in \Sigma_{\text{const}}$, an element $\sigma(c) \in \rho(\tau)$; and
    \item for each $f : (\tau_1, \ldots, \tau_n) \to \tau \in \Sigma_{\text{func}}$, a function $\sigma(f) \in \rho(\tau_1) \times \!\cdots\! \times \rho(\tau_n) \to \rho(\tau)$.
\end{itemize}
Note that $\sigma(c) \in \llbracket \tau \rrbracket_{\rho}$ and $\sigma(f) \in \llbracket \tau_1 \times \cdots \times \tau_n \rightarrow \tau \rrbracket_{\rho}$.
\end{frame}

\begin{frame}
\frametitle{Set-Theoretic Denotational Semantics for Terms in Context*}

Fix a fixed $\rho$ and $\sigma$, we can define the meaning of a lambda term.
In a context $\Gamma = x_1 : \alpha_1, \ldots, x_n : \alpha_n$, the denotational semantics of a term $M$ is a function:

\[
\llbracket \Gamma \vdash M : \alpha \rrbracket_{\rho, \sigma} : \llbracket \alpha_1 \rrbracket_\rho \times \cdots \times \llbracket \alpha_n \rrbracket_\rho \to \llbracket \alpha \rrbracket_\rho
\]

For a $\Gamma$ as above, we will write $\gamma$ for an element of $\llbracket \alpha_1 \rrbracket_\rho \times \cdots \times \llbracket \alpha_n \rrbracket_\rho$ and write $\gamma(x_i)$ for the $i^{\text{th}}$ component of the tuple.
\end{frame}

\begin{frame}
\frametitle{Recursive Definition of Denotation for Terms*}

The denotational semantics $\llbracket \Gamma \vdash M : \alpha \rrbracket_{\rho,\sigma} (\gamma)$ is defined recursively as follows:

\begin{itemize}
    \item $\llbracket \Gamma \vdash x : \alpha \rrbracket_{\rho,\sigma} (\gamma) = \gamma(x)$
    \item $\llbracket \Gamma \vdash \langle \rangle : 1 \rrbracket_{\rho,\sigma} (\gamma) = \star$
    \item $\llbracket \Gamma \vdash c : \tau \rrbracket_{\rho,\sigma} (\gamma) = \sigma(c)$
    \item $\llbracket \Gamma \vdash f(M_1, \ldots, M_n) : \sigma \rrbracket_{\rho,\sigma} (\gamma) = \sigma(f)$
    \pause
    \item $\llbracket \Gamma \vdash \lambda x : \alpha. M : \alpha \rightarrow \beta \rrbracket_{\rho,\sigma} (\gamma) = \lambda x. \llbracket \Gamma, x:\alpha \vdash M : \beta \rrbracket_{\rho,\sigma} (\gamma[x \mapsto v])$
    \pause
    \item $\llbracket \Gamma \vdash M \, N : \beta \rrbracket_{\rho,\sigma} (\gamma) = \llbracket M \rrbracket_{\rho,\sigma}(\gamma)(\llbracket N \rrbracket_{\rho,\sigma}(\gamma))$
    \item $\llbracket \Gamma \vdash \langle M_1, M_2 \rangle : \alpha_1 \times \alpha_2 \rrbracket_{\rho,\sigma} (\gamma) = (\llbracket M_1 \rrbracket_{\rho,\sigma}(\gamma), \llbracket M_2 \rrbracket_{\rho,\sigma}(\gamma))$
    \item $\llbracket \Gamma \vdash \pi_1(M) : \alpha_1 \rrbracket_{\rho,\sigma} (\gamma) = \pi_1(\llbracket M \rrbracket_{\rho,\sigma}(\gamma))$
    \item $\llbracket \Gamma \vdash \pi_2(M) : \alpha_2 \rrbracket_{\rho,\sigma} (\gamma) = \pi_2(\llbracket M \rrbracket_{\rho,\sigma}(\gamma))$
\end{itemize}

Here, $\gamma[x \mapsto v]$ denotes extension of $\gamma$ mapping $x$ to $v$.
\end{frame}

\begin{frame}
\frametitle{Soundness}

\textbf{Theorem:}

Let $\Omega$ be a set of axioms in a signature $\Sigma$.
Let $\rho$ and $\sigma$ be assignments such that, for all $\left(\Gamma \vdash M : \alpha, \Gamma \vdash N : \alpha\right) \in \Omega$, we have $\llbracket \Gamma \vdash M : \alpha \rrbracket_{\rho, \sigma} = \llbracket \Gamma \vdash N : \alpha \rrbracket_{\rho, \sigma}$.
Then, for all valid equations $\Gamma \vdash M = N : \alpha$ we have

\[
\llbracket \Gamma \vdash M : \alpha \rrbracket_{\rho, \sigma} = \llbracket \Gamma \vdash N : \alpha \rrbracket_{\rho, \sigma}
\]

Thus, if we respect the axioms, then equivalent terms have equal denotational semantics. This is the minimum we expect from denotational semantics.

\end{frame}


\begin{frame}
\frametitle{References}

\printbibliography
\end{frame}

\end{document}
