\documentclass[aspectratio=169]{beamer}

\usepackage[style=authoryear]{biblatex}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{stmaryrd}

\title{Introduction to Proving Stuff\textsuperscript{\texttrademark} with Logical Relations}
\author{Jesse Sigal}
\date{November 7, 2024}

\addbibresource{refs.bib}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Attribution}
\begin{itemize}
\item Slides with $*$ at the end of their title were written with the help of GPT 4o.
\item Most things for the calculus are in line with \cite{Crole_1994}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Overview}
\begin{itemize}
    \item What do we want to prove?
    \item Lambda calculus (review?)
    \begin{itemize}
        \item Types
        \item Signature
        \item Syntax
        \item Free variables
        \item Substitution
        \item Typing judgments
        \item Equations-in-context
        \item Equational reasoning rules
        \item Denotational semantics
        \item Soundness
    \end{itemize}
    \item Logical relations
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{What do we want to prove?}

\begin{itemize}
    \item When we write programs, we want to be able to reason about what they do.
    \item But what if we want to prove something about \emph{all} programs in a language?
    \item For example, if we have a language with an integer type, addition, and multiplication.
    \item How could we prove that if we only ever input even numbers that we always get even numbers out?
    \item Logical relations is a proof method that lets us easily prove the above, as well as many more complicated and interesting theorems.
    \item For example, we can prove that every simply typed lambda calculus term terminates!
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Types*}
\[
\alpha, \beta ::= \tau \mid 1 \mid \alpha_1 \times \alpha_2 \mid \alpha \rightarrow \beta
\]

Where:
\begin{itemize}
    \item $\tau$ is a ground type from a fixed set of symbols, e.g.\ $\{\text{Int}, \text{Bool}, \ldots\},$
    \item $1$ is the unit type,
    \item $\alpha_1 \times \alpha_2$ is a product type,
    \item $\alpha \rightarrow \beta$ is a function type.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Signature}
A signature $\Sigma = (\Sigma_{\text{const}}, \Sigma_{\text{func}})$ is composed of two sets, namely
\begin{itemize}
    \item $\Sigma_{\text{const}}$ whose elements are constant symbols $c : \tau$; and
    \item $\Sigma_{\text{func}}$ whose elements are function symbols $f : (\tau_1, \ldots, \tau_n) \to \sigma$.
\end{itemize}
Everything is defined with respect to a signature $\Sigma$.

\medskip

For example, assume that we have $\text{Int}$ as ground type.
Then we could defined $\Sigma = \left(\{\underline{x} : x \in \mathbb{Z}\}, \{+, \times\}\right)$ 

\end{frame}

\begin{frame}
\frametitle{Syntax*}

\[
M, N ::= x \mid \langle \rangle \mid c \mid f(M_1, \ldots, M_n) \mid \lambda x: \alpha. M \mid M \, N \mid \langle M_1, M_2 \rangle \mid \pi_1(M) \mid \pi_2(M)
\]

Where:
\begin{itemize}
    \item $x$ is a variable from a countably infinite set $\{x, y, z, \ldots \}$,
    \item $\langle \rangle$ is the term of type $1$,
    \item $c$ is a constant symbol in $\Sigma_{\text{const}}$,
    \item $f$ is a function symbol in $\Sigma_{\text{func}}$,
    \item $\lambda x: \alpha. M$ is lambda abstraction with $\alpha$ is a type,
    \item $M\, N$ is application,
    \item $\langle M_1, M_2 \rangle$ is a product,
    \item $\pi_1(M)$ and $\pi_2(M)$ are projections.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Free variables*}
The function $\text{FV}(M)$ is defined recursively as follows:
\begin{itemize}
    \item $\text{FV}(x) = \{x\}$
    \item $\text{FV}(\langle \rangle) = \emptyset$
    \item $\text{FV}(c) = \emptyset$
    \item $\text{FV}(f(M_1, \ldots, M_n)) = \bigcup_{i=1}^{n} \text{FV}(M_i)$
    \pause
    \item $\text{FV}(\lambda x: \alpha. M) = \text{FV}(M) \setminus \{x\}$
    \pause
    \item $\text{FV}(M \, N) = \text{FV}(M) \cup \text{FV}(N)$
    \item $\text{FV}(\langle M_1, M_2 \rangle) = \text{FV}(M_1) \cup \text{FV}(M_2)$
    \item $\text{FV}(\pi_1(M)) = \text{FV}(M)$
    \item $\text{FV}(\pi_2(M)) = \text{FV}(M)$
\end{itemize}

\pause
For example, $\text{FV}(\lambda x: \alpha. y \, x) = \{y\}$.

\end{frame}

\begin{frame}
\frametitle{Capture-avoiding substitution*}

Substitution of $N$ for $x$ in $M$ in a capture-avoiding way, denoted $M[x := N]$, is defined recursively as follows:

\begin{itemize}
    \item $x[x := N] = N$
    \item $y[x := N] = y$, for $y \neq x$
    \pause
    \item $\langle \rangle[x := N] = \langle \rangle$
    \item $c[x := N] = c$
    \pause
    \item $f(M_1, \ldots, M_n)[x := N] = f(M_1[x := N], \ldots, M_n[x := N]))$
    \item $(M \, P)[x := N] = (M[x := N]) \, (P[x := N])$
    \item $\langle M_1 , M_2 \rangle[x := N] = \langle M_1[x := N], M_2[x := N] \rangle$
    \item $\pi_1(M)[x := N] = \pi_1(M[x := N])$
    \item $\pi_2(M)[x := N] = \pi_2(M[x := N])$
    \item $\ldots$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Capture-avoiding substitution (continued)*}

Most importantly, we have the rule for abstraction:

\begin{itemize}
    \item $(\lambda y : \alpha. M)[x := N] =
    \begin{cases}
    \lambda y : \alpha. M[x := N] & \text{if } y \neq x \text{ and } y \notin \text{FV}(N) \\
    \lambda z : \alpha. M[y := z][x := N] & \text{if } y = x \text{ or } y \in \text{FV}(N)
    \end{cases}$
\end{itemize}
\pause
Here are two examples:
\begin{itemize}
    \item $(\lambda y : \alpha. x)[x := z] = \lambda y : \alpha. z$
    \item $(\lambda y : \alpha. y \, x)[x := y] = \lambda z : \alpha. z \, y$
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Typing Judgments*}

\[
\infer{\Gamma \vdash x : \alpha}{(x : \alpha) \in \Gamma}
\qquad
\infer{\Gamma \vdash \langle \rangle : 1}{}
\qquad
\infer{\Gamma \vdash c : \tau}{c : \tau \in \Sigma_{\text{const}}}
\]
\pause
\[
\infer{\Gamma \vdash f(M_1, \ldots, M_n) : \sigma}{\Gamma \vdash M_1 : \tau_1 & \ldots & \Gamma \vdash M_n : \tau_n & f : (\tau_1, \ldots, \tau_n) \rightarrow \sigma \in \Sigma_{\text{func}}}
\]
\pause
\[
\infer{\Gamma \vdash \lambda x : \alpha. M : \alpha \rightarrow \beta}{\Gamma, x : \alpha \vdash M : \beta}
\qquad
\infer{\Gamma \vdash M \, N : \beta}{\Gamma \vdash M : \alpha \rightarrow \beta & \Gamma \vdash N : \alpha}
\]
\pause
\[
\infer{\Gamma \vdash \langle M_1, M_2 \rangle : \alpha_1 \times \alpha_2}{\Gamma \vdash M_1 : \alpha & \Gamma \vdash M_2 : \alpha_2}
\qquad
\infer{\Gamma \vdash \pi_1(M) : \alpha_1}{\Gamma \vdash M : \alpha_1 \times \alpha_2}
\qquad
\infer{\Gamma \vdash \pi_2(M) : \alpha_2}{\Gamma \vdash M : \alpha_1 \times \alpha_2}
\]
\end{frame}

\begin{frame}
\frametitle{Equations-in-Context*}

An equation-in-context is expressed as:
\[
\Gamma \vdash M = N : \alpha
\]

The judgments means that in the type context $\Gamma$, the terms $M$ and $N$ are considered equal and both have type $\alpha$.

\medskip

Equations-in-contexts allow us to perform equational reasoning while respecting the types assigned to the variables involved.
\end{frame}

\begin{frame}
\frametitle{Equational Reasoning Rules*}

\[
\infer[\text{(Refl)}]{\Gamma \vdash M = M : \alpha}{\Gamma \vdash M : \alpha}
\]

\[
\infer[\text{(Sym)}]{\Gamma \vdash N = M : \alpha}{\Gamma \vdash M = N : \alpha}
\]

\[
\infer[\text{(Trans)}]{\Gamma \vdash M = P : \alpha}{\Gamma \vdash M = N : \alpha & \Gamma \vdash N = P : \alpha}
\]
\end{frame}

\begin{frame}
\frametitle{Weakening and Substitution Rules*}

\[
\infer[\text{(Weak)}]{\Gamma, x : \beta \vdash M = N : \alpha}{\Gamma \vdash M = N : \alpha}
\]

\[
\infer[\text{(Subs)}]{\Gamma \vdash M[x := P] = N[x := P] : \alpha}{\Gamma, x : \beta \vdash M = N : \alpha & \Gamma \vdash P : \beta}
\]
\end{frame}

\begin{frame}
\frametitle{Rules for Unit and Binary Products*}

\[
\infer[\text{(Unit-Eq)}]{\Gamma \vdash M = \langle\rangle : 1}{\Gamma \vdash M : 1}
\]

\[
\infer[\text{(Proj1)}]{\Gamma \vdash \pi_1(\langle M_1, M_2 \rangle) = M_1 : \alpha_1}{\Gamma \vdash M_1 : \alpha_1 & \Gamma \vdash M_2 : \alpha_2}
\]

\[
\infer[\text{(Proj2)}]{\Gamma \vdash \pi_2(\langle M_1, M_2 \rangle) = M_2 : \alpha_2}{\Gamma \vdash M_1 : \alpha_1 & \Gamma \vdash M_2 : \alpha_2}
\]

\[
\infer[\text{($\eta$-Prod)}]{\Gamma \vdash \langle \pi_1(P), \pi_2(P) \rangle = P : \alpha_1 \times \alpha_2}{\Gamma \vdash P : \alpha_1 \times \alpha_2}
\]
\end{frame}

\begin{frame}
\frametitle{Rules for Functions*}

\[
\infer[\text{($\beta$-Eq)}]{\Gamma \vdash (\lambda x : \alpha. M) \, N = M[x := N] : \beta}{\Gamma \vdash N : \alpha}
\]

\[
\infer[\text{($\eta$-Eq)}]{\Gamma \vdash \lambda x : \alpha. (M \, x) = M : \alpha \rightarrow \beta}{x \not\in \text{FV}(M)}
\]

\[
\infer[\text{($\lambda$-Cong)}]{\Gamma \vdash \lambda x : \alpha. M = \lambda x : \alpha. N : \alpha \rightarrow \beta}{\Gamma, x : \alpha \vdash M = N : \beta}
\]

\end{frame}

\begin{frame}
\frametitle{Denotational Semantics*}

\textbf{Interpretation of Types}:

\begin{itemize}
    \item $\llbracket \tau \rrbracket = G_\tau$
    \item $\llbracket 1 \rrbracket = \{\star\}$
    \item $\llbracket \alpha_1 \times \alpha_2 \rrbracket = \llbracket \alpha_1 \rrbracket \times \llbracket \alpha_2 \rrbracket$
    \item $\llbracket \alpha \rightarrow \beta \rrbracket = \llbracket \alpha \rrbracket \rightarrow \llbracket \beta \rrbracket$
\end{itemize}

\textbf{Interpretation of Terms} (given environment $\rho$):
\begin{itemize}
    \item $\llbracket x \rrbracket_\rho = \rho(x)$
    \item $\llbracket \langle \rangle \rrbracket_\rho = \star$
    \item $\llbracket c \rrbracket_\rho = c$
    \item $\llbracket f(M_1, \ldots, M_n) \rrbracket_\rho = f(\llbracket M_1 \rrbracket_\rho, \ldots, \llbracket M_n \rrbracket_\rho)$
    \item $\llbracket \lambda x : \alpha. M \rrbracket_\rho = \lambda a \in \llbracket \alpha \rrbracket. \llbracket M \rrbracket_{\rho[x := a]}$
    \item $\llbracket M \, N \rrbracket_\rho = \llbracket M \rrbracket_\rho (\llbracket N \rrbracket_\rho)$
    \item $\llbracket \langle M_1, M_2 \rangle \rrbracket_\rho = (\llbracket M_1 \rrbracket_\rho, \llbracket M_2 \rrbracket_\rho)$
    \item $\llbracket \pi_1(M) \rrbracket_\rho = \pi_1(\llbracket M \rrbracket_\rho)$
    \item $\llbracket \pi_2(M) \rrbracket_\rho = \pi_2(\llbracket M \rrbracket_\rho)$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Set Theoretic Denotational Semantics for Types*}

\[
\llbracket \alpha \rrbracket_\rho =
\begin{cases}
\rho(\tau) & \text{if } \alpha = \tau \\
\{\star\} & \text{if } \alpha = 1 \\
\llbracket \alpha_1 \rrbracket_\rho \times \llbracket \alpha_2 \rrbracket_\rho & \text{if } \alpha = \alpha_1 \times \alpha_2 \\
\llbracket \alpha \rrbracket_\rho \rightarrow \llbracket \beta \rrbracket_\rho & \text{if } \alpha = \alpha \rightarrow \beta
\end{cases}
\]

Where:
\begin{itemize}
    \item $\rho$ is an interpretation function that assigns a set $\rho(\tau)$ to each ground type $\tau$, e.g., $\rho(\text{Int}) = \mathbb{Z}$, $\rho(\text{Bool}) = \{ \text{true}, \text{false} \}$.
    \item $\{\star\}$ is the singleton set representing the unit type.
    \item $\times$ denotes the Cartesian product of sets.
    \item $\rightarrow$ denotes the set of all functions from one set to another.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Set Theoretic Denotational Semantics for Terms in Context*}

In a context $\Gamma = x_1 : \alpha_1, \ldots, x_n : \alpha_n$, the denotational semantics of a term $M$ is a function:

\[
\llbracket \Gamma \vdash M : \alpha \rrbracket : \llbracket \alpha_1 \rrbracket_\rho \times \cdots \times \llbracket \alpha_n \rrbracket_\rho \to \llbracket \alpha \rrbracket_\rho
\]

Where:
\begin{itemize}
    \item The interpretation of variables in context $\Gamma$ is given by a substitution $\theta$ such that $\theta(x_i) \in \llbracket \alpha_i \rrbracket_\rho$.
    \item The term $M$ is interpreted via the function produced by $\llbracket \cdot \rrbracket$, respecting the types in the context and yielding a set-theoretic value in $\llbracket \alpha \rrbracket_\rho$.
    \item The interpretation $\llbracket \Gamma \vdash M : \alpha \rrbracket(\theta)$ effectively maps each variable $x_i$ to its semantic value $\theta(x_i)$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Recursive Definition of Denotation for Terms*}

The denotational semantics $\llbracket \Gamma \vdash M : \alpha \rrbracket (\theta)$ is defined recursively as follows:

\begin{itemize}
    \item $\llbracket \Gamma \vdash x : \alpha \rrbracket (\theta) = \theta(x)$
    \item $\llbracket \Gamma \vdash \langle \rangle : 1 \rrbracket (\theta) = \star$
    \item $\llbracket \Gamma \vdash c : \tau \rrbracket (\theta) = \text{const}(c)$, where $\text{const}(c)$ is the interpretation of $c$.
    \item $\llbracket \Gamma \vdash f(M_1, \ldots, M_n) : \sigma \rrbracket (\theta) = \text{func}(f)(\llbracket M_1 \rrbracket(\theta), \ldots, \llbracket M_n \rrbracket(\theta))$, where $\text{func}(f)$ is the function interpretation of $f$.
    \item $\llbracket \Gamma \vdash \lambda x : \alpha. M : \alpha \rightarrow \beta \rrbracket (\theta) = g$, where $g \in \llbracket \alpha \rrbracket_\rho \rightarrow \llbracket \beta \rrbracket_\rho$ is the function such that for all $v \in \llbracket \alpha \rrbracket_\rho$, $g(v) = \llbracket \Gamma, x:\alpha \vdash M : \beta \rrbracket (\theta[x \mapsto v])$.
    \item $\llbracket \Gamma \vdash M \, N : \beta \rrbracket (\theta) = \llbracket M \rrbracket(\theta)(\llbracket N \rrbracket(\theta))$
    \item $\llbracket \Gamma \vdash \langle M_1, M_2 \rangle : \alpha_1 \times \alpha_2 \rrbracket (\theta) = (\llbracket M_1 \rrbracket(\theta), \llbracket M_2 \rrbracket(\theta))$
    \item $\llbracket \Gamma \vdash \pi_1(M) : \alpha_1 \rrbracket (\theta) = \pi_1(\llbracket M \rrbracket(\theta))$
    \item $\llbracket \Gamma \vdash \pi_2(M) : \alpha_2 \rrbracket (\theta) = \pi_2(\llbracket M \rrbracket(\theta))$
\end{itemize}

Here, $\theta[x \mapsto v]$ denotes the substitution function $\theta$ updated to map $x$ to $v$.
\end{frame}

\begin{frame}
\frametitle{Soundness of Denotational Semantics with respect to Equational Theory*}

\textbf{Theorem: Soundness}

Let $\Gamma \vdash M = N : \alpha$ be a valid equation in the equational theory. Then, for any interpretation function $\rho$ and for any substitution $\theta$ that respects the context $\Gamma$, the denotational semantics satisfies:

\[
\llbracket \Gamma \vdash M : \alpha \rrbracket (\theta) = \llbracket \Gamma \vdash N : \alpha \rrbracket (\theta)
\]

\medskip

This theorem asserts that if two terms $M$ and $N$ are provably equal in the equational theory, they have the same denotation in every model, thereby establishing the consistency of the semantics with the equational reasoning.
\end{frame}


\begin{frame}
\frametitle{References}

\printbibliography
\end{frame}

\end{document}
